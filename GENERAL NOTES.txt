module :	00	/	 01	/	02
temps :		15 min	/	1h	/	1H30

===========================
====== GENERAL NOTES ======
===========================
- protected x 2
- ; after class declaration
- #include <map>
	module01	-> Warlock.hpp
	module02	-> SpellBook.hpp
			-> TargetGenerator.hpp
- [ASpell*] BUT [*this] : PARTOUT
- #include <iostream> : Warlock.hpp & ATarget.hpp
- #pragma once :
	= module_01 => ASpell / ATarget / Fwoosh / Dummy
	= module_02 => ASpell / ATarget / Fwoosh / Dummy / BrickWall / Fireball / Polymorph / SpellBook / TargetGenerator


===========================
======== MODULE 01 ========
===========================

ASpell.hpp
	- include ATarget.hpp
	- [class ATarget;]
	- void launch(ATarget const & target) const; ==> const at the end
ASpell.cpp
	- target.getHitBySpell(*this); ==> *this

ATarget.hpp
	- include ASpell.hpp
	- [class ASpell;]
	- void getHitBySpell(ASpell const & spell) const; ==> const at the end

Fwoosh / Dummy
	- pas de private attributs
	- ASpell*/ATarget* clone() const ==> return (new Fwoosh()/Dummy());
WARLOCK.HPP
	- include
		- <map>
		- ASpell.hpp
	void learnSpell(ASpell* spell);
	void forgetSpell(std::string spellName);
	void launchSpell(std::string spellName, ATarget const & target);
	
WARLOCK.CPP
	- destructor destroys
		- delete it->second;
		- _spellBook.clear();
	- learnSpell
		- USE CLONE()
		- pointeur donc ->
========LEARNSPELL
		void Warlock::learnSpell(ASpell* spell)
		{
			if (spell)
				if(_sellBook.find(spell->getName()) == _spellBook.end())
					_spellBook[spell->getName()] = spell->clone();
		}
	
========FORGETSPELL
		void Warlock::forgetSpell(std::string spellName)
		{
			if(_spellBook.find(spellName) != _spellBook.end())
				_spellBook.erase(_spellBook.find(spellName));
		}

========LAUNCHSPELL
		void Warlock::launchSpell(std::string spellName, ATarget & target)		
		{
			if(_spellBook.find(spellName) != _spellBook.end())
				_spellBook[spellName]->launch(target);
		}

========WARLOCK::~WARLOCK()
		Warlock::~Warlock()
		{
			std::cout ...
			for(std::map<std::string, ASpell*>::iterator it = _spellBook.begin() ; it != _spellBook.end(); ++it)
			{
				delete it->second;
			}
			_spellBook.clear();
		}

===========================
======== MODULE 02 ========
===========================

- Swoosh =copy=> Fireball/polymorph
- Dummy =copy=> BrickWall
	
- SpellBook
	=> STD::string Ã  rajouter !
	=> ne pas oublier la map !
	
- Warlock.hpp
	- ONLY CHANGE : remplacer MAP par [SpellBook _spellBook;]
- Warlock.cpp
	ONLY CHANGE :
	- ~Warlock ne destoy plus !
	=> LEARN:	_spellBook.learnSpell(spell);
	=> FORGET:	_spellBook.forgetSpell(spellName);


======== SpellBook::~SpellBook()
{
	for(std::map<std::string, ASpell*>::iterator it = _spellBook.begin() ; it != _spellBook.end() ; ++it)
	{
		delete it->second;
	}
	_spellBook.clear();
}


======== void SpellBook::learnSpell(ASpell* spell)
{
	if(spell)
		_spellBook[spell->getName()] = spell->clone();
}


======== void SpellBook::forgetSpell(std::string const & spellName)
{
	std::map<std::string, ASpell*>::iterator it = _spellBook.find(spellName);
	if (it != _spellBook.end())
	{
		delete it->second;
		_spellBook.erase(it);
	}
}


======== ASpell* SpellBook::createSpell(std::string const & spellName)
{
	ASpell* tmp = NULL;
	if(_spellBook.find(spellName) != _spellBook.end())
		tmp = _spellBook[spellName];
	return  (tmp);
}
