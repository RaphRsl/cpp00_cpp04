GENERAL NOTES
- protected x 2
- ; after class declaration
- #include <map>
	module01	-> Warlock.hpp
	module02	-> SpellBook.hpp
			-> TargetGenerator.hpp
- [ASpell*] BUT [*this] : PARTOUT
- #include <iostream> : Warlock.hpp & ATarget.hpp

===========================



- module02 :
	- Swoosh =copy=> Fireball/polymorph
	- Dummy =copy=> BrickWall
	
	- SpellBook
		=> STD::string Ã  rajouter !
		=> ne pas oublier la map !
	
	- Warlock.hpp
		ONLY CHANGE : remplacer MAP par [SpellBook _spellBook;]
	- Warlock.cpp
		ONLY CHANGE : 
			LEARN:	_spellBook.learnSpell(spell);
			FORGET:	_spellBook.forgetSpell(spellName);



===========================
======== MODULE 01 ========
===========================

ASpell.hpp
	- include ATarget.hpp
	- [class ATarget;]
	- void launch(ATarget const & target) const; ==> const at the end
ASpell.cpp
	- target.getHitBySpell(*this); ==> *this

ATarget.hpp
	- include ASpell.hpp
	- [class ASpell;]
	- void getHitBySpell(ASpell const & spell) const; ==> const at the end

Fwoosh / Dummy
	- pas de private attributs
	- ASpell*/ATarget* clone() const ==> return (new Fwoosh()/Dummy());
WARLOCK.HPP
	- include
		- <map>
		- ASpell.hpp
	void learnSpell(ASpell* spell);
	void forgetSpell(std::string spellName);
	void launchSpell(std::string spellName, ATarget const & target);
	
WARLOCK.CPP
	- destructor destroys
		- delete it->second;
		- _spellBook.clear();
	- learnSpell
		- USE CLONE()
		- pointeur donc ->
========LEARNSPELL
		void Warlock::learnSpell(ASpell* spell)
		{
			if (spell)
				if(_sellBook.find(spell->getName()) == _spellBook.end())
					_spellBook[spell->getName()] = spell->clone();
		}
	
========FORGETSPELL
		void Warlock::forgetSpell(std::string spellName)
		{
			if(_spellBook.find(spellName) != _spellBook.end())
				_spellBook.erase(_spellBook.find(spellName));
		}

========LAUNCHSPELL
		void Warlock::launchSpell(std::string spellName, ATarget & target)		
		{
			if(_spellBook.find(spellName) != _spellBook.end())
				_spellBook[spellName]->launch(target);
		}

========WARLOCK::~WARLOCK()
		Warlock::~Warlock()
		{
			std::cout ...
			for(std::map<std::string, ASpell*>::iterator it = _spellBook.begin() ; it != _spellBook.end(); ++it)
			{
				delete it->second;
			}
			_spellBook.clear();
		}

===========================
======== MODULE 02 ========
===========================

